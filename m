Return-Path: <devicetree-owner@vger.kernel.org>
X-Original-To: lists+devicetree@lfdr.de
Delivered-To: lists+devicetree@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 8EBA850BA11
	for <lists+devicetree@lfdr.de>; Fri, 22 Apr 2022 16:28:02 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240201AbiDVOax (ORCPT <rfc822;lists+devicetree@lfdr.de>);
        Fri, 22 Apr 2022 10:30:53 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:48222 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234227AbiDVOax (ORCPT
        <rfc822;devicetree@vger.kernel.org>); Fri, 22 Apr 2022 10:30:53 -0400
Received: from smtp-out1.suse.de (smtp-out1.suse.de [195.135.220.28])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 977015BD0E
        for <devicetree@vger.kernel.org>; Fri, 22 Apr 2022 07:27:59 -0700 (PDT)
Received: from relay2.suse.de (relay2.suse.de [149.44.160.134])
        by smtp-out1.suse.de (Postfix) with ESMTP id 46809210F3;
        Fri, 22 Apr 2022 14:27:58 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=suse.de; s=susede2_rsa;
        t=1650637678; h=from:from:reply-to:date:date:message-id:message-id:to:to:cc:cc:
         mime-version:mime-version:content-type:content-type:
         in-reply-to:in-reply-to:references:references;
        bh=SIrg+jnlA/ySa4nkLtWhrnBgc7EPWse46JFnnP2g0JM=;
        b=wJ+D928QfglyQyNE79DSFOXsQJZRbwJe+B7gDp3MPRLcvZ1ZP8sU4wuq5n0ICLByBWXQTm
        St8Ta7Wqq1lj8h9H1vUcXpKCapMmKxXaIrRSO0rpUtpw06lpY+QMpqvlL59gGU0QfHaYCW
        lWsRYQkFfwdhUQWnybLsiCbnZ6oanX8=
DKIM-Signature: v=1; a=ed25519-sha256; c=relaxed/relaxed; d=suse.de;
        s=susede2_ed25519; t=1650637678;
        h=from:from:reply-to:date:date:message-id:message-id:to:to:cc:cc:
         mime-version:mime-version:content-type:content-type:
         in-reply-to:in-reply-to:references:references;
        bh=SIrg+jnlA/ySa4nkLtWhrnBgc7EPWse46JFnnP2g0JM=;
        b=v9X9WOEQfEM4u+vaJDADbanymvMXXjCcP9nNgEdusM9tJZ2wWfGCITDXicVuXcbQFSO6gy
        qwXIr5hcaTlBn3AQ==
Received: from alsa1.suse.de (alsa1.suse.de [10.160.4.42])
        by relay2.suse.de (Postfix) with ESMTP id 33B182C14B;
        Fri, 22 Apr 2022 14:27:58 +0000 (UTC)
Date:   Fri, 22 Apr 2022 16:27:58 +0200
Message-ID: <s5hzgkdry4x.wl-tiwai@suse.de>
From:   Takashi Iwai <tiwai@suse.de>
To:     Daniel Kaehn <kaehndan@gmail.com>
Cc:     tiwai@suse.com, alsa-devel@alsa-project.org,
        devicetree@vger.kernel.org
Subject: Re: [PATCH v2 2/2] Add generic serial MIDI driver using serial bus API
In-Reply-To: <20220421172427.703231-3-kaehndan@gmail.com>
References: <20220421172427.703231-1-kaehndan@gmail.com>
        <20220421172427.703231-3-kaehndan@gmail.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
X-Spam-Status: No, score=-4.4 required=5.0 tests=BAYES_00,DKIM_SIGNED,
        DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_MED,SPF_HELO_NONE,
        SPF_PASS autolearn=ham autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <devicetree.vger.kernel.org>
X-Mailing-List: devicetree@vger.kernel.org

On Thu, 21 Apr 2022 19:24:27 +0200,
Daniel Kaehn wrote:
> 
> Generic serial MIDI driver adding support for using serial devices
> compatible with the serial bus as raw MIDI devices, allowing using
> additional serial devices not compatible with the existing
> serial-u16550 driver. Supports only setting standard serial baudrates on
> the underlying serial device; however, the underlying serial device can
> be configured so that a requested 38.4 kBaud is actually the standard MIDI
> 31.25 kBaud. Supports DeviceTree configuration.
> 
> Signed-off-by: Daniel Kaehn <kaehndan@gmail.com>
> ---
> 
> One ugly portion in the code I wanted to point out, but didn't find a
> 'nice' way of solving. `snd_serial_generic_output_write` is called to
> read from ALSA's output MIDI buffer and write to the serdev_device's
> input buffer. While copying directly from the former to the later would
> be desirable for performance, I assume violating the abstraction would
> never be permissable. The current implementation creates an internal buffer of
> an arbitrary size (currently 256) and copies there as an intermediate
> step. Any advice on how to make this better is appreciated.

It's OK, as MIDI data isn't that huge and fast, and the optimization
is done at any time later.

About the code: in general, please avoid the use of snd_printk() and
co.  Those are old helpers, and better to use dev_err(), dev_dbg(),
etc, if possible.

Some more nitpicking:

> +static int snd_serial_generic_ensure_serdev_open(struct snd_serial_generic *drvdata)
> +{
> +	int err = 0;

Superfluous initialization.

> +	unsigned int actual_baud;
> +
> +	if (drvdata->filemode == SERIAL_MODE_NOT_OPENED) {

This expression is rather confusing.  It's essentially a zero check,
and the simple zero check is rather easier to understand that there is
no opener, i.e.

	if (!drvdata->filemode) {
		.....

> +static int snd_serial_generic_input_open(struct snd_rawmidi_substream *substream)
> +{
> +	int err = 0;

Superfluous.

> +	struct snd_serial_generic *drvdata = substream->rmidi->private_data;
> +
> +	snd_printd("snd-serial-generic: DEBUG - Opening input for card %s\n",
> +		drvdata->card->shortname);
> +
> +	err = snd_serial_generic_ensure_serdev_open(drvdata);
> +	if (err < 0) {
> +		snd_printk(KERN_WARNING "snd-serial-generic: failed to open input for card %s",
> +			drvdata->card->shortname);

Spewing an error message at each time would fill up the kernel log
unnecessarily.  Make it a debug message, if you really need to print
something.

> +static int snd_serial_generic_input_close(struct snd_rawmidi_substream *substream)
> +{
> +	struct snd_serial_generic *drvdata = substream->rmidi->private_data;
> +
> +	drvdata->filemode &= ~SERIAL_MODE_INPUT_OPEN;
> +	drvdata->midi_input = NULL;
> +	if (drvdata->filemode == SERIAL_MODE_NOT_OPENED)

Use zero check instead.  (Ditto for *_output functions).

> +#define INTERNAL_BUF_SIZE 256
> +
> +static void snd_serial_generic_output_write(struct snd_rawmidi_substream *substream)
> +{
> +	static char buf[INTERNAL_BUF_SIZE];
> +	int num_bytes;
> +	struct snd_serial_generic *drvdata = substream->rmidi->private_data;
> +
> +	num_bytes = snd_rawmidi_transmit_peek(substream, buf, INTERNAL_BUF_SIZE);
> +	num_bytes = serdev_device_write_buf(drvdata->serdev, buf, num_bytes);
> +	snd_rawmidi_transmit_ack(substream, num_bytes);

This needs to be a loop to process all pending bytes?

> +static int snd_serial_generic_receive_buf(struct serdev_device *serdev,
> +				const unsigned char *buf, size_t count)
> +{
> +	int ret = 0;

Superfluous initialization.

> +static int snd_serial_generic_create(struct serdev_device *serdev,
> +				struct snd_card *card,
> +				struct snd_serial_generic **rserialmidi)
> +{
> +	struct snd_serial_generic *drvdata;
> +	int err;
> +
> +	drvdata = devm_kzalloc(card->dev, sizeof(*drvdata), GFP_KERNEL);
> +	if (!drvdata)
> +		return -ENOMEM;
> +
> +	drvdata->serdev = serdev;
> +	drvdata->card = card;

You can use card's private_data instead of an extra kmalloc().
(Pass sizeof(*drvdata) to the extra_size argument of
snd_devm_card_new()).

> +	if (serdev->dev.of_node) {
> +		err = of_property_read_u32(serdev->dev.of_node, "speed", &drvdata->baudrate);

So, as we rely on of_node, the Kconfig should have the dependency,
too?

> +static int __init alsa_card_serial_generic_init(void)
> +{
> +	snd_printk(KERN_INFO "snd-serial-generic: Generic serial-based MIDI device\n");
> +	return serdev_device_driver_register(&snd_serial_generic_driver);
> +}
> +
> +static void __exit alsa_card_serial_generic_exit(void)
> +{
> +	serdev_device_driver_unregister(&snd_serial_generic_driver);
> +}
> +
> +module_init(alsa_card_serial_generic_init)
> +module_exit(alsa_card_serial_generic_exit)

Those are simplified with module_serdev_device_driver()?


thanks,

Takashi
